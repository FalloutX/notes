<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">

	<title>Elixir Getting Started - FalloutX Notes</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../app.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">FalloutX Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
              
                
                    <li  >
                        <a href="../..">Home</a>
                    </li>
                
              
            
              
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Notes <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">Elixir Getting Started</a>
</li>

                        
                            
<li >
    <a href="../pwa_notes/">Progressive Web Apps</a>
</li>

                        
                            
<li >
    <a href="../datavis_notes/">Data Visualization</a>
</li>

                        
                            
<li >
    <a href="../redux_notes/">Redux</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Ruby</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../ruby/ruby_part_1_codeacademy/">Ruby Notes P1 - CodeAcademy</a>
</li>

        
            
<li >
    <a href="../ruby/ruby_part_2_explanations/">Ruby Notes P2 - Explantions</a>
</li>

        
            
<li >
    <a href="../ruby/ruby_part_3_ruby_monk_intro/">Ruby Notes P3 - Ruby Monk</a>
</li>

        
            
<li >
    <a href="../ruby/ruby_part_4/">Ruby Notes P4 - Ruby Monk Primer Ascent</a>
</li>

        
    </ul>
  </li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Data Analysis</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../data-analysis/l1-data-analysis-process/">L1: Data Analysis Process</a>
</li>

        
    </ul>
  </li>

                        
                        </ul>
                    </li>
                
              
            
              
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Resources <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../resources/learning_ruby/">Learning Ruby</a>
</li>

                        
                            
<li >
    <a href="../../resources/general_dev_resources/">General Dev Resources</a>
</li>

                        
                        </ul>
                    </li>
                
              
            
              
            
              
            
              
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                <!-- <li >
                    <a rel="next" href="../..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../pwa_notes/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li> -->
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#getting-started-with-elixir">Getting Started with Elixir</a></li>
        
            <li><a href="#elixir-data-types">Elixir Data Types.</a></li>
        
            <li><a href="#modules-functions">Modules &amp; Functions</a></li>
        
            <li><a href="#control-flow-in-elixir">Control Flow in Elixir</a></li>
        
            <li><a href="#recursion-in-elixir">Recursion in Elixir</a></li>
        
            <li><a href="#elixir-ecosystem">Elixir Ecosystem.</a></li>
        
            <li><a href="#creating-an-application">Creating an Application.</a></li>
        
            <li><a href="#testing-elixir">Testing Elixir</a></li>
        
            <li><a href="#next-steps">Next Steps</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<div id="main-content-container">
<h1 id="getting-started-with-elixir"><a name="user-content-getting-started-with-elixir" href="#getting-started-with-elixir" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Getting Started with Elixir</h1>
<blockquote>
<p>Updated 25th Janaury 2017.</p>
</blockquote>
<h2 id="elixir-data-types"><a name="user-content-elixir-data-types" href="#elixir-data-types" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Elixir Data Types.</h2>
<ul>
<li>
<p><strong>Numbers</strong> - (no upper range)</p>
<ul>
<li><a href="https://hexdocs.pm/elixir/Integer.html">Integer</a></li>
<li><a href="https://hexdocs.pm/elixir/Float.html">Float</a></li>
</ul>
</li>
<li>
<p><strong>Atoms</strong> (called symbols in Ruby) - <code>:firstname</code> is an atom. <code>:ok</code> and <code>:error</code> are very common atoms in elixir. | <a href="https://hexdocs.pm/elixir/Atom.html">Atoms</a></p>
<ul>
<li>Elixir doesn't have a Boolean type. Instead it uses <code>:true</code> and <code>:false</code> atoms.</li>
<li>Atoms are more memory efficient than strings.</li>
<li><code>:nil</code>, <code>:false</code>, <code>:true</code> can be used without colons at the start, like <code>nil</code>, <code>false</code>, <code>true</code>.</li>
</ul>
</li>
<li>
<p><strong>Strings</strong> are UTF-8 out of the box. | <a href="https://hexdocs.pm/elixir/String.html">Strings</a></p>
<ul>
<li>
<p><code>&lt;&gt;</code> is the concatenation operator.</p>
</li>
<li>
<p><code>"hello" &lt;&gt; " world!"</code> becomes <code>"hello world!"</code></p>
</li>
<li>
<p>String Interpolation is done with <code>"#{}"</code></p>
</li>
<li>
<p><code>"Hello, #{'andy'}"</code> becomes <code>"Hello, andy"</code></p>
</li>
<li>
<p>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir. Single quotes are char lists, double quotes are strings.</p>
</li>
</ul>
</li>
<li>
<p><strong>Tuples</strong></p>
<ul>
<li>Ordered collections of 2-5 items. for more items, use List/Map.</li>
<li>Create a tuple like <code>book = {"programming with elixir", 51002, 90.19}</code></li>
<li>To get 2nd element from the book tuple, <code>elem(book, 1)</code></li>
<li>To change element at 3rd position of the book tuple, <code>put_elem(book, 2, "Newton Taylor")</code></li>
<li><code>put_elem</code> doesn't mutate the book tuple. Data is immutable in elixir.</li>
<li><code>{title, price, author} = book</code>, matches the book tuple to the left hand side variables title, price and author. If you don't need any of the element from book, you can match it with <code>_</code>(underscore).</li>
<li>Tuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation.</li>
</ul>
</li>
<li>
<p><strong>List</strong></p>
<ul>
<li>Better data structure for big collection of data items.</li>
<li>In Elixir, Lists are singly linked. Each element has a pointer to the next element, but no pointer to the prev element. Prepending the easier than appending.</li>
<li><code>hd(my_list)</code> gives the first element (head of the list), and <code>tl(my_list)</code> gives the list minus first element(tail of the list).</li>
<li>Prepending to the list: <code>[89 | my_list]</code>, prepends 89 to the my_list.</li>
<li>Patten matching left-side and right-side works in lists.</li>
<li>Two lists can be concatenated or subtracted using the <code>++/2</code> and <code>--/2</code> operators.</li>
</ul>
</li>
<li>
<p><strong>Immutablity</strong></p>
<ul>
<li>In elixir data is immutable, once a list/tuple is created it cannot be modified.</li>
<li>Immutability helps with concurrency in elixir.</li>
<li>Efficient Memory Use. It knows the memory assigned cannot be modified, so elixir doesn't have to copy stuff.</li>
</ul>
</li>
<li>
<p><strong>Maps</strong></p>
<ul>
<li>Collection of key-value pairs, keys don't have to be atoms. Only one instance of a key is allowed.</li>
<li>syntax - <code>%{ 1 =&gt; {"Nate", "nate@gmail.com"}, 2 =&gt; {"charles", "charles@gmail.com"} }</code></li>
<li>Even tuples can be used as keys for maps.</li>
<li>If they key is an Atom, then you can use dot syntax to access that property, like <code>costumers.nate</code>, else for other you need to use <code>[]</code> syntax, like <code>costumers['charles']</code>.</li>
</ul>
</li>
</ul>
<h2 id="modules-functions"><a name="user-content-modules-functions" href="#modules-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Modules &amp; Functions</h2>
<ul>
<li>
<p><strong>Modules</strong></p>
<ul>
<li>Elixir used do-end blocks instead of curly braces or indents.</li>
</ul>
<pre><code class="elixir">defmodule ExampleModule do
  # Module Code.
end
</code></pre>

</li>
<li>
<p><strong>Module Directives</strong></p>
<ul>
<li><code>import</code> to import other modules into the current module.</li>
<li><code>import IO, only: [puts: 1]</code> will only import <code>puts</code> function from the IO Module.</li>
<li><code>import Kernel, except: [inspect: 1]</code> will import everything from <code>Kernel</code> module except the <code>inspect</code> function.</li>
<li><code>alias ModulePlayground.Misc.Util.Math, as: MyMath</code> will add <code>MyMath</code> alias for rather long name of <code>ModulePlayground.Misc.Util.Math</code>. If <code>as:</code> option in not provided, it would use the last name of the aliased Module as the alias. For <code>ModulePlayground.Misc.Util.Math</code>, the alias without <code>as:</code> would be <code>Math</code>.</li>
<li><code>require</code> is used to bring in Macros from other modules into your module.</li>
</ul>
</li>
<li>
<p><strong>Basic Operators</strong></p>
<ul>
<li><strong>Arithmetic Operators</strong>: <code>*</code>, <code>+</code>, <code>/</code>, <code>-</code>, <code>div/2</code>(for integer division) &amp; <code>rem/2</code>(remainder)</li>
<li>List Concatenation (<code>++</code>) and List Subtraction <code>--</code>.</li>
<li>String Concatenation <code>&lt;&gt;</code></li>
<li><strong>Boolean Operators</strong>(strict): <code>and</code>, <code>or</code> and <code>not</code>. they expect boolean as a first argument.</li>
<li><strong>Boolean Operators</strong>(non-strict): <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>. don't expect boolean as a first argument. only <code>false</code> &amp; <code>nil</code> are falsy in Elixir</li>
<li><strong>Comparision</strong>: <code>==</code>, <code>!=</code>, <code>===</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code> and <code>&lt;</code>.</li>
<li><code>===</code> vs <code>==</code>: <code>===</code> is more strict when comparing floats and integers. <code>1 === 1.0</code> is <code>false</code>, while <code>1 == 1.0</code> is true.</li>
<li>In Elixir, different data types can be compared. <code>1 &lt; :atom</code> is true.</li>
<li>Data Types Sorting Order: <code>number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring</code></li>
</ul>
</li>
<li>
<p><strong>Functions</strong></p>
<pre><code class="elixir">defmodule Sample do # The module that encloses the function

    def SampleFunction do
        #Function code.
    end

end
</code></pre>

<ul>
<li>
<p>last evaluated statement is the default return value of the function, like Ruby.</p>
</li>
<li>
<p><strong>Function Arity</strong> - {function name}/{number of parameters}</p>
</li>
<li>
<p>Shorthand for writing smaller functions.</p>
</li>
</ul>
<pre><code class="elixir">def first([]), do:nil
def first([head | _]), do: head
</code></pre>

<p>​</p>
</li>
<li>
<p><strong>Gaurd Clauses</strong></p>
<ul>
<li>
<p>To safely return sane results when inputs are bit worse than expected, and keep such inputs from entering the saner/more logical function.</p>
</li>
<li>
<p>Guard Clause way to do the above functionality.</p>
</li>
</ul>
<pre><code class="elixir">def first(list) when length(list) == 0, do: nil #This would execute when list is empty.

def first([head | _]), do: head
</code></pre>

</li>
<li>
<p><strong>Default Parameters</strong></p>
<ul>
<li>Specify default parameter with <code>\\</code>(double backslash) symbol. In the below example, <code>val</code> has a default value of 0.</li>
</ul>
<pre><code class="elixir">def prepend(list, val \\ 0) do
    [val | list]
end
</code></pre>

</li>
<li>
<p><strong>Private Functions</strong></p>
<ul>
<li>To define a private function, use the defp macro instead of def macro used to define public functions.</li>
<li>Private Function would be accessible to other functions inside the module it was defined, but not outside.</li>
</ul>
<pre><code class="elixir">defp trace(string) do
    IO.puts &quot;The Value passed to trace is #{string}&quot;
end
</code></pre>

</li>
<li>
<p><strong>Functions as first class citizens</strong></p>
<ul>
<li><em>passing a function as an argument</em>: Need to prefix <code>&amp;</code> for capturing and suffix the function with its Arity.</li>
<li><em>return functions as values from other functions</em></li>
<li><em>assign functions to a variable</em></li>
</ul>
<pre><code class="elixir"># passing a function as an argument
Enum.map(list, &amp;Sample.Utils.sqaure/1)

# assign to a variable
sqaure = &amp;Sample.Utils.sqaure/2
</code></pre>

</li>
<li>
<p><strong>Anonymous Functions</strong></p>
<ul>
<li>to define a anonymous function with <code>fn</code> syntax</li>
<li><strong>Note</strong>: a dot (<code>.</code>) between the variable and parentheses is required to invoke an anonymous function.</li>
<li>Therefore, Elixir makes a clear distinction between anonymous functions and named functions.</li>
<li>Anonymous functions are closures and as such they can access variables that are in scope when the function is defined</li>
</ul>
<pre><code class="elixir">Enum.map(list, fn(x) -&gt; x*x end)
</code></pre>

<ul>
<li>using <code>&amp;</code> capturing syntax</li>
</ul>
<pre><code class="elixir">Enum.map(list, &amp;(&amp;1 * &amp;1))
#&amp;1 captures the first argument

Enum.reduce(list, 0, &amp;(&amp;1 + &amp;2))
# &amp;n captures the nth argument.
</code></pre>

</li>
<li>
<p><strong>Calling the passed function</strong></p>
<ul>
<li>call the pass function <code>f</code> with <code>a</code> argument as <code>f.(a)</code></li>
</ul>
</li>
<li>
<p><strong>Pattern Matching</strong></p>
<ul>
<li>In Elixir, the <code>=</code> operator is actually called the match operator. When the sides of <code>=</code> do not match, a MatchError is raised.</li>
<li>Match operator is also useful for destructuring complex data types.</li>
</ul>
<pre><code class="elixir">iex&gt; {a, b, c} = {:hello, &quot;world&quot;, 42}
{:hello, &quot;world&quot;, 42}
iex&gt; a
:hello
iex&gt; b
&quot;world&quot;
</code></pre>

<ul>
<li>A list also supports matching on its own head and its tail.</li>
</ul>
<p><pre><code class="elixir">iex&gt; [head | tail] = [1, 2, 3]
[1, 2, 3]
iex&gt; head
1
iex&gt; tail
[2, 3]
iex&gt; [h | t] = []  # head-tail matching won't work for an empty list
** (MatchError) no match of right hand side value: []
</code></pre>
- <strong>Pin operator</strong> <code>^</code> can be use to pattern match against an existing variable’s value rather than rebinding the variable.</p>
<p><pre><code class="elixir">iex&gt; x = 1
1
iex&gt; ^x = 2 # Trying to match 1 = 2, will throw Match Error
** (MatchError) no match of right hand side value: 2
</code></pre>
- <strong>Note</strong>: You cannot make function calls on the left side of a match.</p>
</li>
</ul>
<h2 id="control-flow-in-elixir"><a name="user-content-control-flow-in-elixir" href="#control-flow-in-elixir" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Control Flow in Elixir</h2>
<ul>
<li>
<p>Branching logic: if-else, cond, case.</p>
</li>
<li>
<p>Iterating logic: recursion, no loops.</p>
</li>
<li>
<p><strong>If-Else</strong></p>
<pre><code class="elixir">## first functon with If Else

def firstIF(list) do
    if length(list) == 0 do
        nil
    else
        hd(list)
    end
end
</code></pre>

</li>
<li>
<p><strong>Unless</strong> - for the negative condtion instead of If.</p>
<pre><code class="elixir">def firstUnless(list) do
    unless length(list) == 0 do
        hd(list)
  end
end
</code></pre>

<ul>
<li><code>quote EXP</code> prints out the Abstract syntax tree for evaluating the EXP.</li>
</ul>
</li>
<li>
<p><strong>Cond</strong> macro</p>
<pre><code>```elixir
#Getting Day Abbreviation using the cond macro.
def day_abbreviation(day) do
    cond do
        day == :Monday -&gt; "M"
        day == :Tuesday -&gt; "Tu"
        day == :Wednesday -&gt; "W"
        day == :Thursday -&gt; "Th"
        day == :Friday -&gt; "F"
        day == :Saturday -&gt; "Sa"
        day == :Sunday -&gt; "Su"
        true -&gt; "Invalid Day"
    end
end
```
</code></pre>
</li>
<li>
<p><strong>Case</strong></p>
<ul>
<li>Case statements are really useful combined with Pattern Matching capabilities of Elixir.</li>
<li>You can also combine Gaurd Clauses with case statements for narrowing down cases.</li>
</ul>
<pre><code class="elixir">def describe_date(date) do
    case date do
        {1, _, _} -&gt; &quot;Brand New Month!&quot;
        {25, 12, _} -&gt; &quot;Merry Christmas&quot;
        {25, month, _} -&gt; &quot;Only #{12-month} months until Christmas!&quot;
        {31, 10, _} -&gt; &quot;Happy Halloween&quot;
        {_, _ , _} -&gt; &quot;Just an average day!&quot;
    end
end
</code></pre>

</li>
</ul>
<h2 id="recursion-in-elixir"><a name="user-content-recursion-in-elixir" href="#recursion-in-elixir" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Recursion in Elixir</h2>
<blockquote>
<p>To understand what recursion is, you must first understand recursion.</p>
</blockquote>
<ul>
<li>Writing a map function with Recursion.</li>
</ul>
<pre><code class="elixir">def map([], _), do: []
def map([head | tail], f) do
    [f.(head) | map(tail, f)]
end
</code></pre>

<ul>
<li>
<p><strong>Tail Recursion</strong></p>
<ul>
<li>only happens when the last operation a function performs is recursion.</li>
</ul>
</li>
</ul>
<pre><code class="elixir"># tail_map written with tail recursion instead of Recursion.
# also need reverse method to reverse the result.

def reverse(list), do: reverse(list, [])
def reverse([], reversed), do: reversed
def reverse([hd | tl], reversed), do: reverse(tl, [hd | reversed])


def tail_map([hd | tl], f), do: tail_map(tl, f, [f.(hd)])
def tail_map([], _, result), do: reverse(result)
def tail_map([hd | tl], f, result), do: tail_map(tl, f, [f.(hd) | result]
</code></pre>

<h2 id="elixir-ecosystem"><a name="user-content-elixir-ecosystem" href="#elixir-ecosystem" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Elixir Ecosystem.</h2>
<ul>
<li>
<p><strong>Basics</strong>: Mix - Build Tool &amp; Hex - Package Manager.</p>
</li>
<li>
<p><strong>Mix</strong> - Task Runner, Build Tool for Elixir.</p>
<ul>
<li><a href="https://elixirschool.com/lessons/basics/mix/">Mix | Elixir School</a></li>
<li><a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html">Introduction to Mix</a></li>
<li><code>mix help</code> to list all the mix commands.</li>
<li><code>mix local.hex</code> to install hex - package manager.</li>
</ul>
</li>
<li>
<p><strong><code>mix new</code></strong></p>
<ul>
<li>for scaffolding a new elixir application.</li>
<li><code>mix new app_name --sup</code> creates a new elixir application named <code>app_name</code> w/ supervisor. <code>app_name</code> needs to be in snake_case.</li>
</ul>
</li>
<li>
<p><strong>Supervisors &amp; Umbrellas</strong></p>
<ul>
<li><strong>Supervisor</strong> process is only responsible for supervising other processes in the application and restart them if they crash.</li>
<li><strong>Umbrella</strong> project is the one which has other elixir projects underneath it. A Grouping of similar elixir apps bundled into a single project.</li>
</ul>
</li>
<li>
<p><strong>Hex</strong> - <a href="https://hex.pm/">Website</a></p>
<ul>
<li>The package manager for Elixir Ecosystem.</li>
<li><code>mix.exs</code> files's <code>deps</code> function contains the dependencies list.</li>
<li><code>mix deps.get</code> to fetch and install the dependencies.</li>
</ul>
</li>
</ul>
<h2 id="creating-an-application"><a name="user-content-creating-an-application" href="#creating-an-application" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Creating an Application.</h2>
<ul>
<li>
<p><strong>Project Structure</strong></p>
<ul>
<li><code>mix.exs</code> - <code>project</code> function contains config of the project like elixir version, project version, dependencies etc. <code>application</code> function contains the other applications that need to be started for our application to get started.</li>
<li><code>lib</code> folder contains our application code as well as our application module.</li>
<li><code>config</code> folder holds files that are used for config properties.</li>
<li><code>deps</code> folder is where dependencies get installed.</li>
<li><code>test</code> is the conventional folder for your tests.</li>
</ul>
</li>
<li>
<p><strong>A Short Description of the Application</strong></p>
<ul>
<li>This Application will read lines from a file, choose a random line and send that line as a tweet.</li>
</ul>
</li>
<li>
<p><strong>FileReader Module</strong>
<pre><code class="elixir">
# This Reads a file, and returns a random line from the file.
defmodule MyFirstApp.FileReader do
    def get_strings_to_tweet(filepath) do
        File.read!(filepath)
        |&gt; String.split(&quot;\n&quot;)
        |&gt; Enum.map(&amp;String.trim/1)
        |&gt; Enum.filter(&amp;String.length(&amp;1) &lt;= 140)
        |&gt; Enum.random()
    end
end

</code></pre></p>
</li>
<li>
<p><strong>Tweet Module</strong></p>
</li>
</ul>
<pre><code class="elixir">defmodule MyFirstApp.Tweet do
    def send(str) do
        # Configure the Extwitter Module for accessing twitter.
        ExTwitter.configure(:process, [
            consumer_key: System.get_env(&quot;ELIXIR_APPS_TWITTER_CONSUMER_KEY&quot;),
            consumer_secret: System.get_env(&quot;ELIXIR_APPS_TWITTER_CONSUMER_SECRET&quot;),
            access_token: System.get_env(&quot;ELIXIR_APPS_TWITTER_ACCESS_TOKEN&quot;),
            access_token_secret: System.get_env(&quot;ELIXIR_APPS_TWITTER_ACCESS_SECRET&quot;)
            ])
        # Send tweet.
        ExTwitter.update(str)
    end

    def send_random(file) do
        # this would send a random line from a file as a tweet.
        MyFirstApp.FileReader.get_strings_to_tweet(file) |&gt; send
    end
end
</code></pre>

<ul>
<li>
<p><strong>Behaviours</strong></p>
<ul>
<li>Defines a set of functions to be implemented.</li>
<li>Ensure that a module implements ALL functions in that set.</li>
<li>More like Interfaces in traditional OO languages.</li>
</ul>
</li>
<li>
<p><strong>Creating a Tweet Server</strong></p>
<ul>
<li>Using GenServer, which is a behaviour in Elixir.</li>
</ul>
</li>
</ul>
<pre><code class="elixir">
defmodule MyFirstApp.TweetServer do
  use GenServer # GenServers are behaviours in Elixir

  def start_link() do
    # hardcoding the name of the server
    # start_link will call init.
    GenServer.start_link(__MODULE__, :ok, name: :tweet_server)
  end

  def init(:ok) do
    {:ok, %{}}
  end

  def handle_cast({:tweet, tweet}, _) do
    # Async
    # handle_call is sync.
    MyFirstApp.Tweet.send(tweet)
    {:noreply, %{}}
  end

  def tweet(tweet) do
    # This will call handle_cast above
    GenServer.cast(:tweet_server, {:tweet, tweet})
  end

end

</code></pre>

<ul>
<li>
<p><strong>Adding Tweet Server in Supervision Tree</strong></p>
<ul>
<li>
<p>Add TweetServer in the supervision children list in <code>start</code> function of the application.ex</p>
</li>
<li>
<p><strong>File</strong>: lib/my_first_app/application.ex</p>
</li>
</ul>
</li>
</ul>
<pre><code class="elixir">def start(_type, _args) do
  import Supervisor.Spec, warn: false


  children = [
    worker(MyFirstApp.TweetServer, []) # Adding TweetServer in the supervision tree.
  ]

  opts = [strategy: :one_for_one, name: MyFirstApp.Supervisor]
  Supervisor.start_link(children, opts)
end
</code></pre>

<ul>
<li>
<p><strong>TweetServer processes</strong></p>
<ul>
<li><code>Process.whereis(:tweet_server)</code> to get the process ID of the tweet_server. This is not a OS process ID, but elixir process ID.</li>
<li><code>Process.whereis(:tweet_server) |&gt; Process.exit(:kill)</code> to kill the tweet server.</li>
<li>But since tweet server is in the Supervision tree, it'll be started again after we killed it.</li>
</ul>
</li>
<li>
<p><strong>Schedule Sending Tweets</strong></p>
</li>
</ul>
<pre><code class="elixir">defmodule MyFirstApp.Scheduler do
  def schedule_file(schedule, file) do
    Quantum.add_job(schedule, fn -&gt; MyFirstApp.FileReader.get_strings_to_tweet(file)
    |&gt; MyFirstApp.TweetServer.tweet end)
  end

end
</code></pre>

<ul>
<li>
<p><strong>Adding Scheduler to the start of the applicaiton</strong></p>
<ul>
<li>modifying the <code>start</code> function in the <code>application.exs</code> file.</li>
</ul>
</li>
</ul>
<pre><code class="elixir">
def start(_type, _args) do
  import Supervisor.Spec, warn: false

  # Define workers and child supervisors to be supervised
  children = [
    # Starts a worker by calling: MyFirstApp.Worker.start_link(arg1, arg2, arg3)
    worker(MyFirstApp.TweetServer, [])
  ]

  # See http://elixir-lang.org/docs/stable/elixir/Supervisor.html
  # for other strategies and supported options
  opts = [strategy: :one_for_one, name: MyFirstApp.Supervisor]
  process = Supervisor.start_link(children, opts)
  MyFirstApp.Scheduler.schedule_file(&quot;*/5 * * * *&quot;,
  Path.join(&quot;#{:code.priv_dir(:my_first_app)}&quot;, &quot;Sample.txt&quot;))

  process
end
</code></pre>

<h2 id="testing-elixir"><a name="user-content-testing-elixir" href="#testing-elixir" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Testing Elixir</h2>
<ul>
<li><code>mix test</code> to run the tests</li>
<li><code>mix test FILEPATH</code> to run the tests located at the <code>FILEPATH</code>.</li>
<li><code>mix test --only TAGNAME</code> to run the test tagged <code>TAGNAME</code>.</li>
</ul>
<pre><code class="elixir"># Tagging a test
@tag watching: true
test &quot;this test will fail&quot; do
  assert 2 + 3 == 5
end
</code></pre>

<ul>
<li>
<p><strong>ExUnit</strong></p>
<ul>
<li><code>use ExUnit.Case</code> needs to be in every Test Module.</li>
<li>Try to mimick directory structure of the app in the tests folder.</li>
</ul>
</li>
<li>
<p><strong>Testing File Reader Module</strong></p>
<ul>
<li>
<p>Updated File Reader Module
<pre><code class="elixir"># lib/my_first_app/file_reader.ex

defmodule MyFirstApp.FileReader do
  # Divided the module into two parts, one that reads the file and other that picks the string, to improve testability.
  def get_strings_to_tweet(filepath) do
    File.read!(filepath)
    |&gt; pick_string
  end

  def pick_string(str) do
    str
    |&gt; String.split(&quot;\n&quot;)
    |&gt; Enum.map(&amp;String.trim/1)
    |&gt; Enum.filter(&amp;String.length(&amp;1) &lt;= 140)
    |&gt; Enum.random()
  end
end
</code></pre></p>
</li>
<li>
<p>Tests for File Reader Module
<pre><code class="elixir"># test/my_first_app/file_reader_test.exs

defmodule FileReaderTest do
  use ExUnit.Case

  import MyFirstApp.FileReader
  test &quot;Passing a file should return a string&quot; do
    str = get_strings_to_tweet Path.join &quot;#{:code.priv_dir(:my_first_app)}&quot;, &quot;Sample.txt&quot;

    assert str != nil
  end

  test &quot;Will not return a line longer than 140 chars&quot; do
    str = get_strings_to_tweet Path.join &quot;#{:code.priv_dir(:my_first_app)}&quot;, &quot;too_long.txt&quot;
    IO.puts str
    assert str == &quot;short line&quot;
  end

  test &quot;An Empty string should return an empty string&quot; do
    str = pick_string &quot;&quot;

    assert str == &quot;&quot;
  end
end
</code></pre></p>
</li>
</ul>
</li>
<li>
<p><strong>Mocking out File Reader</strong></p>
<ul>
<li>By Default, <code>ExUnit</code> doesn't have mocking ability baked in.</li>
<li>Mocking allows us to intercept calls to a specific module and redirect them to a function we wrote for testing.</li>
<li>You can use <a href="https://hex.pm/packages/mock"><strong>Mock Library</strong></a> to perform mocking.</li>
<li><code>with_mock</code> is the main mocking function in Mock Library.</li>
<li>You can use <a href="https://hex.pm/packages/mix_test_watch"><strong>Mix Test Watch Library</strong></a> to automatically run tests when the some file changes occur. Command for that is <code>mix test.watch</code></li>
<li>Example mocking the File Module
<pre><code class="elixir">test &quot;The string returned should be trimmed&quot; do
  with_mock File, [read!: fn(_) -&gt; &quot; ABC &quot; end] do
    str = get_strings_to_tweet &quot;doesnt_exist.txt&quot;

    assert str == &quot;ABC&quot;
  end
end
</code></pre></li>
</ul>
</li>
<li>
<p><strong>DocTest</strong></p>
<ul>
<li>A way of putting basic module tests in the docstrings of the module.</li>
<li>docstrings start with <code>@doc """</code> and end with <code>"""</code></li>
<li>You can write doctest by writing the call to the function after <code>iex&gt;</code> and expected value in the next line.</li>
<li>To run doctest write <code>doctest MODULE</code> in the test file.</li>
</ul>
</li>
</ul>
<pre><code class="elixir"># lib/my_first_app/file_reader.ex

defmodule MyFirstApp.FileReader do

  @doc &quot;&quot;&quot;
  This Function will take the path to a file and return a string that can be
  tweeted out

  The Following is a DocTest

  iex&gt; MyFirstApp.FileReader.get_strings_to_tweet &quot;priv/doc.txt&quot;
  &quot;ABC&quot;
  &quot;&quot;&quot;


  def get_strings_to_tweet(filepath) do
    #...
  end
  #...
end
</code></pre>

<h2 id="next-steps"><a name="user-content-next-steps" href="#next-steps" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Next Steps</h2>
<ul>
<li>
<p><strong>Reference</strong></p>
<ul>
<li><a href="http://elixir-lang.org/crash-course.html">Elixir Syntax Crash Course</a></li>
<li><a href="http://elixir-lang.org/getting-started/introduction.html">Elixir Guides</a></li>
<li><a href="https://hexdocs.pm/elixir/">Elixir Official Docs</a></li>
<li><a href="https://github.com/itsgreggreg/elixir_quick_reference">Elixir Quick Reference</a></li>
</ul>
</li>
<li>
<p><strong>Learning More of Elixir</strong></p>
<ul>
<li><a href="https://github.com/christopheradams/elixir_style_guide">Elixir Style Guide</a></li>
<li><a href="https://elixirschool.com/">Elixir School</a></li>
<li><a href="http://exercism.io/languages/elixir/about">Exercism.io Elixir Problems</a></li>
</ul>
</li>
<li>
<p><strong>Tools</strong></p>
<ul>
<li><a href="https://github.com/rrrene/credo">Credo - Static Code Analysis tool</a> - like linters in other languages.</li>
</ul>
</li>
<li>
<p><strong>Resources</strong></p>
<ul>
<li><a href="https://elixirstatus.com/">Elixir Status</a> - posts/blogs and other content related to elixir.</li>
<li>#myelixirstatus on twitter.</li>
<li><a href="https://soundcloud.com/elixirfountain">Elixir Fountain Podcast</a></li>
<li><a href="https://www.youtube.com/watch?v=_O-bLuVhcCA&amp;list=PLE7tQUdRKcyYoiEKWny0Jj72iu564bVFD">Elixir Conf 2016</a></li>
</ul>
</li>
<li>
<p><strong>Explanations</strong></p>
<ul>
<li><a href="http://stackoverflow.com/questions/18011784/why-are-there-two-kinds-of-functions-in-elixir">Why are there two kinds of functions in Elixir?</a></li>
</ul>
</li>
</ul>
</div>

<div id="progress-bar"></div></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>This site is built with <a href="http://www.mkdocs.org/"> MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>